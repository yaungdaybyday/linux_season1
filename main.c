
/*arm架构下实现C参数从右往左入栈的过程如下，应用此原理可以实现函数printf（const char* p,...），
 *其中指针p指向的字符串中的%的个数表明了后面的有用的参数个数。
 */

/*	说明：在此例子中，调用函数（调用者）为main，被调用函数（被调者）为add;
 *	ATPCS 规定arm架构的栈为满减栈（FD）:栈顶比栈底地址小（栈向下增长），栈顶指向栈中最后一个元素（满栈）
 *  
 *		首先arm架构的参数传递规则如下：若参数个数少于等于4个，用r0-r3传参，若大于四个，
 *	则在调用函数（调用者）中开辟栈空间存放后面的参数（位于调用者的栈空间的最后，栈空间的前面存放调用者函数的局部变量），后面的参数从右往左依次存放在栈中。
 *  如果需要多次调用其他函数，则在尾部开辟含最多参数的函数对应的（参数-4：多余的参数）个数的栈。这样子在调用所有的函数时，参数的堆栈空间都连续了（若某个被调用函数的参数个数不足，调动函数的参数栈栈顶空着就好）
 *		在本例中a,b,c,d四个参数通过r0-r4传递，多余的参数，从右往左入栈，先sp-=4，存f;再sp-=4,存e（f的地址比e的高，）。
 *		然后进行函数调用。
 *		在进入被调用函数时，编译器会根据是否为不定参数来决定被调用函数的栈的结构。
 *		1.若不是不定参数，即参数数量固定
 *			1）若参数数量（x+1）少于等于4个，则r0-rx（传递的参数）依次放在它开辟的栈后面部分（r0在高，r3在低。），局部变量仍然然在栈空间的前面
 *			2）若参数数量大于4个，r0-r3同上，放在栈里，同时多余的参数就直接在调用者的栈空间寻址，被调用函数本身不开辟相应的栈保存他们，
 *			因此在访问后面的参数时实际上访问的不是拷贝值，而是实实在在的在调用者函数内部栈空间尾部的变量。
 *			总结：此种情况下参数地址不连续，前4个地址在被调用函数的栈空间，后几个参数的地址在调用者函数的栈空间，
				中间部分被 被调用函数的堆栈部分打断（如lr等寄存器的现场保护堆栈打断：stmdb	sp!, {fp, ip, lr, pc}）。
 *		2.若是不定参数，则参数数量不固定，arm编译器的处理如下：
 *				前1-4个参数保存在调用者的r0-rx中，后几个参数（若有的话）保存在调用者的栈空间尾部，且从右往左入栈；
 *			进入被调用函数，它会先将r0-rx（前几个参数）入栈（被调用函数的栈）保护 ，stmdb	sp!, {r0, r1, r2, r3}，由于编号高的寄存器先入栈，则r3地址高，r0地址低。
 *			这样子就使得所有的参数地址实际上形成连续状态，且整体上满足参数从右往左入栈顺序。接着再stmdb	sp!, {fp, ip, lr, pc}
 *			总结：不定参数的各参数在栈中存放时连续的，且满足从右往左的顺序入栈，但是，实际上他们属于不同的栈空间，
 *			前1-4个属于被调用者的栈空间，后面的参数（若还有的话）属于调用者的栈空间。
 */
 /*多一句嘴，x86架构下的C参数在栈中也是从右往左入栈，且在调用函数(调用者)的栈中的地址就是连续的（这些参数不会被保存到被调用函数的栈中），没有像arm这么多屁事*/
 
 
 /*以下两个函数原型二选一，可以看看反汇编代码
  *	当选择第一个原型时，得到的value值不是想要的值，因为：首先参数在栈中地址不连续，其次又不是从右往左入栈。指针无法直接了然的实现对参数的操作。
  *	当选择第二个原型时，得到的是期望的value值，此时参数在栈中地址连续，且从右往左入栈（虽然不在同属于同一个函数栈空间）。可以方便的用指针对参数操作，（通过指针加减）。
  */
//int add(int a,int b,int c,int d,int e，int f)   
int add(int a,...)
{
	int* p=&a;
	int value=0;
	value+=*p++;
	value+=*p++;
	value+=*p++;
	value+=*p++;
	value+=*p++;
	value+=*p;

	return value;
}
int  main()
{
	int value = 1;
	int sum = 2;
	value =	add(1,2,3,4,5,6);
//	sum =	add(1,2,3,4,sum,6,7);
//	sum =	add(1,2,3,4,sum,6,7,8,9);
	
	return 1;
}

